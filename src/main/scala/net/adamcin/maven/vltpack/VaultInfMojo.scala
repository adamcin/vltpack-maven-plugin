package net.adamcin.maven.vltpack

import org.apache.maven.plugins.annotations.{Parameter, Mojo, LifecyclePhase}
import org.apache.maven.plugin.logging.Log
import java.io.File
import scalax.io.Resource
import java.util.{Properties, Collections}
import com.day.jcr.vault.packaging.PackageId
import com.day.jcr.vault.fs.config.DefaultWorkspaceFilter
import com.day.jcr.vault.fs.api.PathFilterSet
import com.day.jcr.vault.fs.filter.DefaultPathFilter

/**
 *
 * @version $Id: VaultInfMojo.java$
 * @author madamcin
 */
@Mojo(
  name = "vault-inf",
  defaultPhase = LifecyclePhase.PREPARE_PACKAGE)
class VaultInfMojo extends BaseMojo with OutputParameters with BundlePathParameters with IdentifiesPackages {

  final val DEFAULT_VAULT_SOURCE = "${project.build.outputDirectory}/META-INF/vault"
  final val DEFAULT_CONFIG = "com/day/jcr/vault/fs/config/defaultConfig-1.1.xml"

  @Parameter(defaultValue = DEFAULT_VAULT_SOURCE)
  val vaultSource: File = null

  @Parameter
  val properties = Collections.emptyMap[String, String]

  override def execute() {
    super.execute()
    generatePropertiesXml()
    generateFilterXml()
    generateConfigXml()
  }

  def getResourceFromClasspath(name: String) = {
    Resource.fromInputStream(getClass.getClassLoader.getResourceAsStream(name)).
      addCloseAction(IOUtil.inputCloser)
  }

  override def printParams(log: Log) {
    super.printParams(log)
    log.info("vaultSource = " + vaultSource)
  }

  def generateFilterXml() {
    val file = new File(vaultSource, "filter.xml")

    val filter = new DefaultWorkspaceFilter

    if (file.exists()) {
      val sourceFilter = new DefaultWorkspaceFilter
      sourceFilter.load(file)
      filter.getFilterSets.addAll(sourceFilter.getFilterSets)
    }

    val embedBundles = embedBundlesDirectory.listFiles
    if (embedBundles.size > 0) {
      val bundleFilterSet =
        if (filter.covers(bundleInstallPath)) {
          filter.getCoveringFilterSet(bundleInstallPath)
        } else {
          val set = new PathFilterSet(bundleInstallPath)
          set.addExclude(new DefaultPathFilter(bundleInstallPath + "(/.*)?"))
          filter.getFilterSets.add(set)
          set
        }

      embedBundles.foreach {
        (bundle) => bundleFilterSet.addInclude(new DefaultPathFilter(bundleInstallPath + "/" + bundle.getName))
      }
    }

    val embedPackages = embedPackagesDirectory.listFiles
    if (embedPackages.size > 0) {
      val packageFilterSet =
        if (filter.covers(PackageId.ETC_PACKAGES)) {
          filter.getCoveringFilterSet(PackageId.ETC_PACKAGES)
        } else {
          val set = new PathFilterSet(PackageId.ETC_PACKAGES)
          set.addExclude(new DefaultPathFilter(PackageId.ETC_PACKAGES + "(/.*)?"))
          filter.getFilterSets.add(set)
          set
        }

      embedPackages.foreach {
        (pkg) => identifyPackage(pkg) match {
          case Some(id) => packageFilterSet.addInclude(new DefaultPathFilter(id.getInstallationPath))
          case None => getLog.warn("Failed to identify package: " + pkg)
        }
      }
    }

    getLog.info("generating " + filterXml)
    val filterResource = Resource.fromFile(filterXml)
    filterResource.truncate(0)
    Resource.fromInputStream(filter.getSource).addCloseAction(IOUtil.inputCloser).
      copyDataTo(filterResource)
  }

  def generatePropertiesXml() {
    val props = new Properties()

    props.putAll(properties)

    props.setProperty("packageFormatVersion", "2")

    if (!props.containsKey("group")) {
      props.setProperty("group", project.getGroupId.replace(".", "/"))
    }

    if (!props.containsKey("name")) {
      props.setProperty("name", project.getArtifactId)
    }

    if (!props.containsKey("version")) {
      props.setProperty("version", project.getVersion)
    }

    if (!props.containsKey("description") && project.getDescription != null) {
      props.setProperty("description", project.getDescription)
    }

    val id = new PackageId(props.getProperty("group"),  props.getProperty("name"),  props.getProperty("version"))
    props.setProperty("path", id.getInstallationPath)

    getLog.info("generating " + propertiesXml)
    val propertiesResource = Resource.fromFile(propertiesXml)
    propertiesResource.truncate(0)
    propertiesResource.outputStream.acquireFor {
      (f) => props.storeToXML(f, "generated by vltpack-maven-plugin")
    }
  }

  def generateConfigXml() {
    val file = new File(vaultSource, "config.xml")

    getLog.info("generating " + configXml)
    if (file.exists()) {
      Resource.fromFile(file).copyDataTo(Resource.fromFile(configXml))
    } else {
      Resource.fromClasspath(DEFAULT_CONFIG).copyDataTo(Resource.fromFile(configXml))
    }
  }



}